Fonction readN(): entier
debut 
    ecrire("Enter N!")
    lire(n)
    tant que n pas dans [2..20] faire
        Ecrire ("Enter N again !")
        lire(n)
    
    retourner n
fin 

TDOL: 
n => entier


Procedure fillArr(@li:tabT, n:entier):
debut 
    a <- 0
    b <- 0
    pour i de 0 a n faire 
        ecrire("Give A")
        lire a 
        ecrire ("Give B")
        lire(b)
        li[i].a  <- a 
        li[i].b <- b 
    fin pour 
fin 
tdol 
a => entier 
b => entier 
i => entier 


Procedure showArr (li:tabT, n:entier)
debut 
    pour i de 0 a n faire 
        ecrire(li[i])
    fin pour 
fin 
tdol 
i => entier 

Procedure fillArrM(@marr:tabM, li:tabT, n:entier)
debut 

    pour i de 0 a n faire 
        marr[i]<- RacineCarre((li[i]["a"] X (li[i]["a"] ) + (li[i]["b"] X li[i]["b"])) // forgot the power in french algo !
    fin pour 


fin

tdol
i => entier 


Procedure Sorting (li:tabT, mis:tabM, n:entier):
debut 
    flip <- 0
    flipobj <- ? \ {} // this is an object ! 
    pour i de 0 a n-1 faire 
        si mis[i] < mis[i+1] 
        flip <- mis[i] 
        mis[i] = mis[i+1] 
        flipobj <- li[i]
        li[i] <- li[i+1]
        li[i+1] <- flipobj 
        Sorting(li, mis, n)
    fin pour 




fin 
tdol 
i => entier 
flip =>  reel 


Procedure showT(mist:tabM, n:entier)
debut 
    retourner 0 return 0 for now !

fin 




algo Ex1 
debut 
    n <- readN()
    fillArr(l, n)
    fillArr(m, l, n )
    Sorting (l,m,n)
    showArr(l, n)
    showArr(m,n)
    showT(m, n)
fin 



tdo 
n -> entier 
m -> tableau tabM
l -> tableau tabT


